<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSH-Agent 代理]]></title>
    <url>%2F2020%2F06%2F07%2Fssh-agent%2F</url>
    <content type="text"><![CDATA[前言在我学习 ansible 的时候，其官方文档中提到使用 ssh-agent 来管理密钥，用于免密登录远程节点；经过我的努力研究，终于参透其理，下述通过 5W1H 方法对它的使用进行简单的总结： What—什么是 ssh-agent ?SSH-Agent 是一个代理程序，用于帮助我们管理私钥，可以存储用户的身份密钥(identity keys)和密钥密码(passphrases) Where—哪里会用到 ssh-agent ？ 使用不同的密钥连接到不同的主机时，需要手动指定对应的密钥，ssh代理可以帮助我们选择对应的密钥进行认证，不用手动指定密钥即可进行连接； 当私钥设置了密码，我们又需要频繁的使用私钥进行认证时，ssh代理可以帮助我们免去重复的输入密码的操作。 When—什么时候会用到 ssh-agent ？当你已经将服务器对应的密钥和密码添加到 ssh-agent中，此时使用 SSH 登陆其他服务器时 ssh-agent 就会自动选择对应的是身份密钥和密钥密码进行身份验证。你只需要输入： 1ssh username@ip地址 Why—为什么要使用 ssh-agent ？SSH-Agent代理程序可以让我们默认使用密钥登录其他服务器，而无需再次输入密码或 passphrases 。这实现了单点登录（SSO）的形式。 How—如何使用 ssh-agent ?[^注]:下述命令均基于 CentOS 7 启动ssh-agent它有两种启动方式，使用前需要确保你已经安装了 openssh ，最小化安装的系统需要安装依赖： 1yum install openssh-clients 1、ssh-agent $SHELL 它会在当前的 shell 中启动一个子 shell，ssh-agent 程序运行在这个子 shell 中，在 centos 中，$SEHLL 就是 bash。运行后可通过 pstree 命令来查看进程树： 1234567[root@localhost ~] ssh-agent bash[root@localhost ~] pstreesystemd─┬─VGAuthService ├─sshd───sshd───bash───bash─┬─pstree │ └─ssh-agent [root@localhost ~] yum -y install psmisc # 如果没有 pstree 命令需要安装 此时就已经进入到了子 shell 中了，ssh-agent 也运行在这里，当我们退出当前的子 shell，ssh-agent 进程也会随之消失。 12345[root@localhost ~] exitexit[root@localhost ~] pstreesystemd─┬─VGAuthService ├─sshd───sshd───bash───pstree 2、eval ’ssh-agent‘ 它会在当前 sheel 直接开启一个 ssh-agent 进程，并返回一个 PID 。 123456[root@localhost ~] eval `ssh-agent`Agent pid 30406[root@localhost ~] pstreesystemd─┬─VGAuthService ├─ssh-agent ├─sshd───sshd───bash───pstree 此时即使退出当前 shell 连接，ssh-agent 进程依然存在。需要使用 ssh-agent -k 命令关闭该进程，如果当前的 shell 意外断开了，就只能通过 kill 命令来停止了： 123456789[root@localhost ~] ssh-agent -kunset SSH_AUTH_SOCK;unset SSH_AGENT_PID;echo Agent pid 30406 killed;[root@localhost ~] ps -ef | grep ssh-agentroot 30406 1 0 20:01 ? 00:00:00 ssh-agentroot 30549 30494 0 20:01 pts/0 00:00:00 grep --color=auto ssh-agent[root@localhost ~] kill -9 30406 将私钥添加到 ssh-agent这里我们在 ostack01 上提前生成了三对密钥，并远程安装至服务器 ostack02（不会的可以参考 为SSH设置密钥登录），它们之间的关系如下： 密钥名称 密钥密码 对应服务器 对应账户 id_rsa root123 ostack02：192.168.60.143 root id_rsa_empty 无 ostack02：192.168.60.143 user id_rsa_admin admin123 ostack02：192.168.60.143 admin 此时我们分别使用三个密钥去免密登录 ostack02 的三个账户，你就会发现： 123ssh root@192.168.60.143ssh -i /root/.ssh/id_rsa_empty user@192.168.60.143ssh -i /root/.ssh/id_rsa_admin admin@192.168.60.143 每次登录 root 用户时还需要输入密钥密码 每次登录 user 用户时还需要手动指定私钥 每次登录 admin 用户时不仅需要指定私钥，还要输入密钥密码-* 为什么使用了密钥之后登录服务器反而更加麻烦了？尤其当主机或账户过多时，每次登录都需要输入私钥密码，极其繁琐。此时，就需要用到 ssh-agent 了： [注]:需要保证 ssh-agent 已经运行，否则使用 ssh-add 命令会报错。 12345678910[root@ostack01 .ssh] ssh-add /root/.ssh/id_rsaEnter passphrase for /root/.ssh/id_rsa: Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)[root@ostack01 .ssh] ssh-add /root/.ssh/id_rsa_emptyIdentity added: /root/.ssh/id_rsa_empty (/root/.ssh/id_rsa_empty)[root@ostack01 .ssh] ssh-add /root/.ssh/id_rsa_adminEnter passphrase for /root/.ssh/id_rsa_admin: Identity added: /root/.ssh/id_rsa_admin (/root/.ssh/id_rsa_admin) 使用密钥登录服务器SSH-Agent 可以帮我们管理密钥，在一个 SSH 会话中，只需要在添加时输入一次私钥密码，之后再次连接该服务器时则无需输入密钥密码即可成功登入： 1234567891011121314151617[root@ostack01 .ssh] ssh root@192.168.60.143Last login: Mon Jun 15 00:36:23 2020 from 192.168.60.139[root@ostack02 ~] exitlogoutConnection to 192.168.60.143 closed.[root@ostack01 .ssh] ssh -i /root/.ssh/id_rsa_empty user@192.168.60.143Last login: Mon Jun 15 00:36:17 2020 from 192.168.60.139[user@ostack02 ~]$ exitlogoutConnection to 192.168.60.143 closed.[root@ostack01 .ssh] ssh -i /root/.ssh/id_rsa_admin admin@192.168.60.143Last login: Mon Jun 15 00:38:18 2020 from 192.168.60.139[admin@ostack02 ~]$ exitlogoutConnection to 192.168.60.143 closed. 由此可见 ssh-agent可以帮助我们免去重复输入私钥密码的操作，但还是需要指定密钥。 常用命令最后总结一下常用的命令： ssh-agent 常用命令： 1234567891011usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash] [-P pkcs11_whitelist] [-t life] [command [arg ...]] ssh-agent [-c | -s] -kOptions: -a bind_address 强制将 Unix 域套接字绑定到给定的文件路径，而不是默认套接字 -c 强制在标准输出上生成 C-shell 命令。默认情况下，会自动检测到 shell -d 启用调试模式 -E fingerprint_hash 指定用于生成 SSH 密钥的算法。有效值包括md5和sha256。 -k 杀死当前正在运行的 ssh-agent 进程 -s 强制/bin/sh在标准输出上生成 Bourne shell 命令。默认情况下，会自动检测 shell -t life 指定密钥在 ssh-agent 中的有效期。默认将密钥保留在其内存中 ssh-add 常用命令： 12345678usage: ssh-add [options] [file ...]Options: -l 查看 ssh-agent 已经添加的私钥 -L 查看ssh-agent已经添加的私钥对应的公钥 -d 删除指定的私钥 -D 删除所有私钥 -x 锁定 ssh-agent 代理，必须输入密码，加锁后将不再提供任何服务 -X 解锁 ssh-agent 代理，需输入锁定密码]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为SSH设置密钥登录]]></title>
    <url>%2F2020%2F05%2F30%2Fssh-key%2F</url>
    <content type="text"><![CDATA[Linux服务器登录方法一般我们会通过账户、密码的方式远程运维Linux服务器，但是密码有被暴力破解的可能，所以一般采用下述两种方式： 禁用22端口，启用其他端口用于 SSH 登录，或禁用 root 账户； 为服务器设置密钥，通过密钥登录。 原理：利用密钥生成器制作一对密钥：公钥和私钥，将公钥添加到服务器的某个账户上，将私钥下载到本地；然后在客户端利用私钥进行认证和登录。也可以将公钥复制到其他账户甚至主机，使用同一个私钥登录。 注意：本文所有命令基于 CentOS 7.8 操作 加固 SSH 账户密码登录修改默认端口例：此处将远程登录端口修改为3389 1、查看端口是否已被占用，无返回结果表示没有被占用 12[root@ostak02 ~] netstat -anp | grep 3389[root@ostak02 ~] yum install net-tools # 如果上述命令执行失败，则需要安装 net-tools 2、修改 SSH 端口为 3389，此处可以保留 22 端口，避免修改失败导致无法登录。 12345678[root@localhost ~] vim /etc/ssh/sshd_config# If you want to change the port on a SELinux system, you have to tell SELinux about this change.# semanage port -a -t ssh_port_t -p tcp #PORTNUMBERPort 22Port 3389 # 增加3389端口#AddressFamily any#ListenAddress 0.0.0.0#ListenAddress :: 该配置文件 sshd_config 中其他参数的作用： PermitRootLogin no // 禁止 Root 用户登录 MaxAuthTries 3 // 输入密码最大失败次数为 3 PasswordAuthentication no // 禁用密码登录 PubkeyAuthentication yes // 允许密钥认证 3、防火墙开放对应端口 123456[root@localhost ~] firewall-cmd --zone=public --add-port=3389/tcp --permanent # 开放 3389 端口success[root@localhost ~] firewall-cmd --reload # 重新读取防火墙配置success[root@localhost ~] firewall-cmd --zone=public --query-port=3389/tcp # 查看端口是否添加成功yes 4、在SELinux中添加对应的 SSH 端口 如果没有 SELinux 的管理工具 semanage 需要先安装: 12[root@localhost ~] yum provides semanage[root@localhost ~] yum install policycoreutils-python # semanage的依赖工具包 此时可以正常使用 semanage 命令了： 12345[root@localhost ~] semanage port -l | grep ssh # 查询当前 ssh 服务端口ssh_port_t tcp 22[root@localhost ~] semanage port -a -t ssh_port_t -p tcp 3389 # 向 SELinux 中添加 ssh 端口[root@localhost ~] semanage port -l | grep sshssh_port_t tcp 3389, 22 5、重启SSH服务，登陆验证 重启 sshd 服务后就可以使用新添加的端口登录了，可以看到成功登陆了，最后不要忘了把 22 端口注释掉哦。 12345[root@localhost ~] systemctl restart sshd.service # 重启 ssh 服务# 此处使用另外一台 Linux 登录测试：[root@ostak01 ~] ssh root@192.168.60.143 -p 3389Last login: Wed Jun 3 00:36:14 2020 from 192.168.60.1[root@localhost ~] 使用密钥免密登录生成密钥对首先需要通过密码登录服务器，生成的密钥默认存放于当前账户的家目录： 12345678910111213141516171819202122[root@ostack02 ~] ssh-keygen # 创建密钥Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): # 直接回车，使用默认名称/root/.ssh/id_rsa already exists.Enter passphrase (empty for no passphrase): # 直接回车，密码滞空Enter same passphrase again: # 确认密码，直接回车Your identification has been saved in /root/.ssh/id_rsa. # 私钥Your public key has been saved in /root/.ssh/id_rsa.pub. # 公钥The key fingerprint is:SHA256:8AbiBv9sGvbeGthI9gHHZ8D4of0NivCLnXoPnsp2ySk root@ostack02The key's randomart image is:+---[RSA 2048]----+| o. || ..o. || . o+=.o || .+.+o*. || o*..oSo || +oB.o. . || +*=B || .EoXB o || .+*+o=.. |+----[SHA256]-----+ 然后就会在 ~/.ssh 目录下生成一对 2048 位无密码的 ras 密钥，ssh-keygen 的常用参数如下： -t：指定生成密钥的类型，默认使用SSH2d的rsa -f：指定生成密钥的文件名，默认id_rsa（私钥id_rsa，公钥id_rsa.pub） -b：指定密钥长度（bits），RSA最小要求768位，默认是2048位；DSA密钥必须是1024位（FIPS 1862标准规定） -C：添加一个注释 在此提醒，私钥 id_rsa 非常重要，需要妥善保存！ 公钥的安装安装至当前服务器将公钥安装在当前服务器 ostack02 中，就可以使用私钥在本地免密登录 ostack02 了。 12345678[root@ostack02 ~] cd ~/.ssh[root@ostack02 .ssh] cat id_rsa.pub &gt;&gt; authorized_keys[root@ostack02 .ssh] ll # 注意文件权限, .ssh 目录为700total 16-rw-r--r--. 1 root root 2357 Jun 3 23:17 authorized_keys-rw-------. 1 root root 1675 Jun 3 23:09 id_rsa-rw-r--r--. 1 root root 395 Jun 3 23:09 id_rsa.pub-rw-r--r--. 1 root root 176 Jun 2 00:42 known_hosts 安全至远程服务器如果想通过同一个私钥登录另一台服务器 ostack01 或想通过 ostack02 登录 ostack01 怎么办呢？可以将公钥也注册到需要登陆的服务器，这里以 ostack01(192.168.60.142) 为例： 123456[root@ostack02 .ssh] ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.60.142[root@ostack02 .ssh] cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPjXkFWHAphIzxduIQbLumViWfI2bs8gm2WPj7Y2vERNOfwHIjUqtKExrYKNDwO4etbxJ8opY1wKWdbFLAd7uwLOJc0uP37hdY3WOsj+W7X0i+MTIRmek0oM5xzAbXVWjLsuzK0Djzv0TE8I8L2nOOcehz7DxgXdW7+GRmF6w+T6M18aTmltKh7SHEEbBToq5SNlP2VDo3fmVWh3/v58Q5KPZDHNnpdQ4L9RuiGcwcR3jbIbrKymqJfTPlfOiuiYDBb6wfsQ9+rB20bEKXMSNAGs5yF5KB69lIHSadnN3Ef8YjTTAO/mKZrkx42xZaYuVuSIwJ0DXUHz1MnqvfJ8Pz root@ostack02# 此时登录 ostack01，会在 /root/.ssh/ 下生成 authorized_keys 文件，通过查看比对发现和公钥是一致的[root@ostak01 .ssh] cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPjXkFWHAphIzxduIQbLumViWfI2bs8gm2WPj7Y2vERNOfwHIjUqtKExrYKNDwO4etbxJ8opY1wKWdbFLAd7uwLOJc0uP37hdY3WOsj+W7X0i+MTIRmek0oM5xzAbXVWjLsuzK0Djzv0TE8I8L2nOOcehz7DxgXdW7+GRmF6w+T6M18aTmltKh7SHEEbBToq5SNlP2VDo3fmVWh3/v58Q5KPZDHNnpdQ4L9RuiGcwcR3jbIbrKymqJfTPlfOiuiYDBb6wfsQ9+rB20bEKXMSNAGs5yF5KB69lIHSadnN3Ef8YjTTAO/mKZrkx42xZaYuVuSIwJ0DXUHz1MnqvfJ8Pz root@ostack02 私钥的使用SSH 软件使用私钥登录服务器将私钥提取至本地，用于后续登录，这里以Xsheel为例： 12345678[root@ostack02 .ssh] sz /root/.ssh/id_rsa[root@ostack02 .ssh] yum install lrzsz # 如果没有 sz 命令，可通过 yum 安装使用说明：1. sz命令发送文件到本地： sz filename2. rz命令本地上传文件到服务器： rz执行该命令后，在弹出框中选择要上传的文件即可。 在本地打开 Xsheel 连接服务器，弹出的对话框中选择 Public Key，浏览选中下载的私钥。因为我们没有设置密码，所以直接确定，就可以成功登录该服务器了。 1[C:\~]$ ssh root@192.168.60.142 Linux 使用私钥登录服务器使用 ostack02 登录 ostack01： 123[root@ostack02 .ssh] ssh root@192.168.60.142 Last login: Thu Jun 4 00:46:45 2020 from 192.168.60.1[root@ostak01 ~] ssh基于密钥进行认证时，默认会使用~/.ssh/*id_rsa进行认证，当使用非默认名称的私钥进行认证时，需要使用 -i 参数手动指明对应的私钥： 12# 需按照上述步骤添加一个新的密钥 id_rsa_demo[root@ostack02 .ssh] ssh -i ~/.ssh/id_rsa_demo root@192.168.60.142 关闭 SELinux虚拟机建议关闭，如果想详细了解什么是SELinux，请转百度百科:SELinux ，这里只介绍关闭的方法： 临时关闭，重启后失效： 1[root@ostack02 .ssh] setenforce 0 彻底关闭，告别离奇问题： 1234567891011121314[root@ostack02 .ssh] vim /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.# SELINUX=enforcing # 保留原来的配置SELINUX=disable # 新复制一行，设置为 disable# SELINUXTYPE= can take one of three values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted 修改 SSH 配置文件在安装了公钥的服务器上编辑 /etc/ssh/sshd_config 文件，允许密钥登陆、禁用密码登录。 123456789101112131415161718[root@ostak01 ~] vim /etc/ssh/sshd_config# If you want to change the port on a SELinux system, you have to tell# SELinux about this change.# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER##Port 22#AddressFamily any#ListenAddress 0.0.0.0#ListenAddress ::RSAAuthentication yes # 允许 rsa 密钥认证PubkeyAuthentication yes # 允许密钥认证PermitRootLogin yes # 此处请留意 root 用户能否通过 SSH 登录，默认为yes：PasswordAuthentication no # 上面已经验证密钥可以成功登录，可以禁用密码登录。HostKey /etc/ssh/ssh_host_rsa_key[root@ostak01 ~] systemctl restart sshd.service # 重启 ssh 服务]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米6刷机]]></title>
    <url>%2F2020%2F05%2F04%2FMi-Flash%2F</url>
    <content type="text"><![CDATA[我的小米6作为2017年的旗舰，小米6也算是陪我度过了2年的大学生活。通过它我也定格了很多美好的大学时光，得以留存在我的相册里。不过随着小米10的发布和雷军的远程施法，导致我的小米6系统越来越卡顿，并且总是在刷地铁、出示支付码等重要时候死机，不能作为我的主力手机使用了。更换了新手机后就想着基于它835的芯片和优秀的硬件，通过刷机让它获得新生。 第一次刷机难免经验不足，也有很多次变砖的情况，不过经过我的不懈努力和两天的钻研，总算是成功救活并赋予它新生。下面是我的一些刷机经验： 数据备份刷机前必不可少的就是数据备份，这里推荐一个APP：手机克隆可以完美迁移数据，华为手机间甚至可以保留APP登录账户、密码和应用数据。 切换至开发版如果你的系统是稳定版本，需要卡刷到开发版获取root权限，但是开发版的root权限是阉割的，并不适合我们后面自己定制化，所以需要以开发版为跳板，再刷入第三方ROM。 1、用手机浏览器访问MIUI官网下载小米6的开发版系统到手机上； 2、在设置→我的设备→MIUI版本界面，点击右上角三个小点点，手动选择安装包后在打开的文件管理器中选中自己下载好的镜像点击确认（一般是在Download文件夹中）；之后等待手机重启后就切换到开发版本了。 注：如果没有手动选择安装包选项，在MIUI版本界面快速点击3下MIUI图标就出来了 解BL锁BL锁全称是BootLoader，其功能就是限制用户刷第三方ROM和降级系统，在锁住BL的情况下，用户是无法刷第三方ROM和第三方recovery的，同时也会对root权限做限制。 正常启动：BootROM -&gt; Bootloader -&gt; Boot.img (Linux kernel)-&gt; system.img(Android) 刷机启动：Bootloader -&gt; recovery.img -&gt; 第三方ROM FastBoot：Bootloaer-&gt;烧写分区镜像 3、在需要解锁的设备中登录已经具备解锁权限的小米账号，并进入设置 -&gt; 开发者选项 -&gt; 设备解锁状态中绑定账号和设备； 4、绑定成功后，手动进入Bootloader模式（关机后，同时按住开机键和音量下键）； 5、浏览器访问MIUI解锁下载解锁工具，在PC端的小米解锁工具中，登录相同的小米账号，并通过USB连接手机； 6、点击PC端解锁工具的解锁按钮，根据提示信息等待指定时间后再次尝试或者立即解锁； PS：如何查看手机是否已经解锁 1.进入“设置”-“我的设备”-“全部参数”界面，连续点击七次“MIUI版本号”开启“开发者选项”功能。 2.然后返回“更多设置”界面，就可以找到“开发者选项”菜单，点击进入并找到“设备解锁状态”可以看到解锁情况。 刷入第三方Recovery刷第三方Recovery有两种方式，分别是卡刷和线刷。这里介绍卡刷方式，只需要一部手机即可比较方便。 7、下载第三方recovery：建议从酷安下载Official TWRP，在TWRP FLASH→SELECT A DEVICE中选择系统版本Xiaomi Mi 6 –sagit，再选择recovery镜像，此处选择最新的twrp-3.3.1.2-sagit.img下载即可。 8、下载刷入软件：镜像助手，选择刷入RECOVERY.img,选中下载好的twrp-3.3.1.2-sagit.img确认等待重启即可。 注意： 第一次启动软件时需要授权root权限，开发版打开“安全中心”APP，点击“应用管理”-“权限”-“ROOT权限说明”允许即可 进入recovery会提示输入您的开机密码/手势，输入正确才能解密data分区 手动进入Recovery：先把手机关机，在关机的状态下住手机的音量上键+电源键不放，过一会手机即可进入recovery的界面 刷入第三方ROM9、双清手机：进入Recovery界面后，点击“清除”，并滑动按钮恢复出厂。提示成功后再点击“格式化Date分区”完成双清。注意：手机格式化Date分区后需重启再次进入Recovery界面才可写入 10、下载第三方ROM至手机，推荐先下载至电脑，再通过数据线复制到手机。此处我使用的时AOSP的系统Xiaomi Mi 6 (sagit)。可以根据自己的手机型号下载对应的系统版本。With GApps表示该系统已经内置了谷歌套件，不需要单独安装。 10、安装第三方ROM：点击安装，选择第三方ROM安装包（一般是.zip），滑动按钮刷入系统。可以勾选上安装完成后重启，等待一会儿，就可以进入系统了！！ 注意：内部存储根目录为/sdcard Q&amp;A变砖后如何救回来1、前往MIUI社区下载稳定版系统包，并解压（推荐解压至纯英文路径） 2、手机进入FastBoot通过线刷工具刷入系统 详细教程参考：官网线刷教程]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS网卡制作bond]]></title>
    <url>%2F2020%2F04%2F06%2Flinux-bond%2F</url>
    <content type="text"><![CDATA[什么是网卡 bond网卡绑定，也称作网卡捆绑。就是将两个或者更多的物理网卡绑定成一个虚拟网卡，使其共用一个IP地址。主要用以提供负载均衡或者冗余，增加网络带宽；保证当一个网卡坏掉时，不会影响业务。更多使用的是其冗余模式，此时需要注意绑定的网卡需要和不同的交换机连接，提高可靠性。 Kernels 2.4.12 及以后的版本都自带 bonding 模块，可以通过以下命令确定系统内核是否支持 bonding ,这里我以 Vmware 环境中搭建的 CentOS 7.6 为例： 12345[root@localhost network-scripts] cat /etc/redhat-release # 查看系统版本CentOS Linux release 7.6.1810 (Core) [root@localhost network-scripts] cat /boot/config-3.10.0-957.el7.x86_64 | grep -i bondingCONFIG_BONDING=m # m即代表支持 网卡 bond 的7种模式目前网卡绑定共有七种模式（0~6）:bond 0、bond 1、bond 2、bond 3、bond 4、bond 5、bond 7。 mod=0 ，即：(balance-rr) Round-robin policy（平衡抡循环策略） 特点：传输数据包顺序是依次传输，即第1个包走eth0，下一个包就走eth1直到最后一个传输完毕；此模式提供负载平衡和容错能力。 缺点：因为数据包从不同的接口发出，客户端很有可能会出现数据包无序到达的问题导致重新发送，降低网络的吞吐量。 mod=1，即： (active-backup) Active-backup policy（主-备份策略） 特点：同一时间只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备。提供了容错能力；bond的MAC地址是唯一的，以避免switch(交换机)发生混乱； 缺点：资源利用率较低，在有 N 个网络接口的情况下，资源利用率为1/N。 mod=2，即：(balance-xor) XOR policy（平衡策略） 特点：基于指定的传输 HASH 策略传输数据包，提供负载平衡和容错能力 策略：(源MAC地址 XOR 目标MAC地址) % slave数量，可通过xmit_hash_policy选项指定传输策略。 mod=3，即：broadcast（广播策略） 特点：在所有的网络接口上传输每个数据包，提供了容错能力。 注意：此模式适用于金融等其他对网络可靠性要求较高的场景。 mod=4，即：(802.3ad) IEEE 802.3ad Dynamic link aggregation（IEEE 802.3ad 动态链接聚合） 特点：创建一个聚合组，它们共享同样的速率和双工设定。外出流量的slave选举是基于传输hash策略，该策略可以通过xmit_hash_policy选项从缺省的XOR策略改变到其他策略。 条件： ethtool支持获取每个slave的速率和双工设定 switch(交换机)支持IEEE 802.3ad Dynamic link aggregation 协议 需要对端 switch 做端口聚合配置 mod=5，即：(balance-tlb) Adaptive transmit load balancing（适配器传输负载均衡） 特点：不需要任何特别的switch(交换机)支持的通道bonding，动态的根据当前负载分配外出流量，如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。并行发送，无法并行接收。 条件：ethtool支持获取每个slave的速率 mod=6，即：(balance-alb) Adaptive load balancing（适配器适应性负载均衡） 特点：mod 5 的基础上增加了对IPV4流量的接收负载均衡(receive load balance, 简称rlb)，而且不需要任何switch(交换机)的支持。可并行发送，并行接收数据包。 条件： ethtool支持获取每个slave的速率； 底层驱动支持设置设备的硬件地址，保证每个bond 中的 slave 都有一个唯一的硬件地址。 配置 bond如下所示，我电脑目前有三张网卡，现需要将网卡 ens37、ens38 绑定为虚拟网卡 bond 0 12345678910111213141516171819202122232425[root@localhost ~] ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:37 brd ff:ff:ff:ff:ff:ff inet 192.168.60.132/24 brd 192.168.60.255 scope global noprefixroute dynamic ens33 valid_lft 1439sec preferred_lft 1439sec inet6 fe80::fa69:4c61:ecd5:d707/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:41 brd ff:ff:ff:ff:ff:ff inet 192.168.60.139/24 brd 192.168.60.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::e12c:2edf:a904:4721/64 scope link noprefixroute valid_lft forever preferred_lft forever4: ens38: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:4b brd ff:ff:ff:ff:ff:ff inet 192.168.60.140/24 brd 192.168.60.255 scope global noprefixroute ens38 valid_lft forever preferred_lft forever inet6 fe80::8ee5:2f0a:20c:9cd/64 scope link noprefixroute valid_lft forever preferred_lft forever 关闭 NetworkManager 服务生产环境下 我们一般都是手动配置网络，以静态地址为主不需要系统的网络管理工具，因此我们就会将它禁用掉，命令如下： network 服务主要管理网卡的配置 NetworkManager 用于管理系统网络连接、允许用户管理网络连接的客户端程序 12[root@localhost ~] systemctl stop NetworkManager # 临时关闭，开机后恢复[root@localhost ~] systemctl disable NetworkManager # 永久关闭，慎用 载入 bond 模块123[root@localhost ~] modprobe bonding # 加载bong 模块[root@localhost ~] lsmod | grep bonding # 确认模块是否加载成功bonding 152656 0 修改网卡配置文件为需要制作bond的网卡添加MASTER、SLAVE配置项，删除其他多余配置信息。注：操作前不要忘记为虚拟机打快照或备份原有网卡文件 1234567891011121314151617[root@localhost ~] cd /etc/sysconfig/network-scripts/[root@localhost network-scripts] cp -a ifcfg-ens37 ifcfg-ens37.bak # -a 参数为保留原文件属性的前提下复制文件[root@localhost network-scripts] cp -a ifcfg-ens38 ifcfg-ens38.bak[root@localhost network-scripts] vi ifcfg-ens37TYPE="Ethernet"BOOTPROTO="static"DEVICE="ens37"ONBOOT="yes"SLAVE="yes" # 增加该项MASTER="bond0" # 增加该项[root@localhost network-scripts]# vi ifcfg-ens38TYPE="Ethernet"BOOTPROTO="static"DEVICE="ens38"ONBOOT="yes"SLAVE="yes" # 增加该项MASTER="bond0" # 增加该项 新建 bond 配置文件在 /etc/sysconfig/network-scripts/ 目录下新建 bond 配置文件，设置 bond 网卡的IP地址 12345678[root@localhost network-scripts] vi ifcfg-bond0DEVICE="bond0"BOOTPROTO="static"ONBOOT="yes"TYPE="bond"IPADDR="192.168.60.139"GATEWAY="192.168.60.2"NETMASK="255.255.255.0" 修改 modprobe.d 下的 bonding 文件若在 /etc/modprobe.d/ 目录下没有 bonding.conf 文件，需要手动新建，输入以下内容: 123[root@localhost network-scripts] vi /etc/modprobe.d/bonding.confalias bond0 bondingoptions bond0 miimon=100 mode=1 # mode=1 表示网卡bond模式为1；miimon=100代表网络链路检测频率100ms检查一次，如果出现问题则切换到备用网卡。 重启网络使配置生效此时可以看到网卡 ens37、ens38 上 master 为 bond 0，表示配置成功。注意做了bonding的这两块网卡是使用同一个MAC地址，避免对端交换机发生混乱。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@localhost ~] ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:37 brd ff:ff:ff:ff:ff:ff inet 192.168.60.142/24 brd 192.168.60.255 scope global dynamic ens33 valid_lft 1622sec preferred_lft 1622sec inet6 fe80::20c:29ff:feeb:f337/64 scope link valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master bond0 state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:41 brd ff:ff:ff:ff:ff:ff4: ens38: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master bond0 state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:41 brd ff:ff:ff:ff:ff:ff5: bond0: &lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 00:0c:29:eb:f3:41 brd ff:ff:ff:ff:ff:ff inet 192.168.60.139/24 brd 192.168.60.255 scope global bond0 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:feeb:f341/64 scope link valid_lft forever preferred_lft forever[root@localhost ~] cat /proc/net/bonding/bond0Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)Bonding Mode: fault-tolerance (active-backup) # bonding模式是主备Primary Slave: NoneCurrently Active Slave: ens37 # 目前使用的网卡MII Status: upMII Polling Interval (ms): 100Up Delay (ms): 0Down Delay (ms): 0Slave Interface: ens37MII Status: upSpeed: 1000 MbpsDuplex: fullLink Failure Count: 0Permanent HW addr: 00:0c:29:eb:f3:41Slave queue ID: 0Slave Interface: ens38MII Status: upSpeed: 1000 MbpsDuplex: fullLink Failure Count: 0Permanent HW addr: 00:0c:29:eb:f3:4bSlave queue ID: 0 测试bond因为上述配置 mode=1 主备模式，可以在ping百度过程中然后断开一个网卡，此时ping不会中断。 12345678910111213141516171819202122[root@localhost modprobe.d] ping www.baidu.comPING www.a.shifen.com (39.156.66.18) 56(84) bytes of data.64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=128 time=46.7 ms64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=128 time=56.0 ms64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=3 ttl=128 time=35.4 ms64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=4 ttl=128 time=69.9 ms64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=5 ttl=128 time=115 ms^C--- www.a.shifen.com ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 4026msrtt min/avg/max/mdev = 35.406/64.817/115.845/27.920 ms[root@localhost modprobe.d] ifdown ens37 # 关掉ens37网卡[root@localhost ~] cat /proc/net/bonding/bond0 Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)Bonding Mode: fault-tolerance (active-backup)Primary Slave: NoneCurrently Active Slave: ens38 # 主网卡已经切换为ens38MII Status: upMII Polling Interval (ms): 100Up Delay (ms): 0Down Delay (ms): 0 Q&amp;AVMware环境测试不适配问题 问题描述： linux网卡bonging的备份模式在vmware workstation虚拟中做就会出现错误，导致 bond 0 启动后无备份模式的效果。当使用ifdown eth0后，网络出现不通现象。 原因分析：bond0获取mac地址有两种方式：①从第一个活跃网卡中获取mac地址，然后其余的SLAVE网卡的mac地址都使用该mac地址、②使用fail_over_mac参数，使bond0使用当前活跃网卡的mac地址，mac地址随着活跃网卡的转换而变。 解决方法：在配置 bonding 文件时设置 fail_over_mac=1 123[root@localhost modprobe.d] vi /etc/modprobe.d/bonding.confalias bond0 bondingoptions bond0 miimon=100 mode=1 fail_over_mac=1 设置多个 bond 口①多个 bond 口的模式相同 1234[root@localhost network-scripts] vi /etc/modprobe.d/bonding.confalias bond0 bondingalias bond1 bondingoptions bonding max_bonds=2 miimon=200 mode=1 # max_bonds表示配置的bond口个数 ②多个 bond 口的模式不同 1234[root@localhost network-scripts] vi /etc/modprobe.d/bonding.confalias bond0 bondingoptions bond0 miimon=100 mode=1install bond1 /sbin/modprobe bonding -o bond1 miimon=200 mode=0]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS中为网卡添加 VLAN TAG]]></title>
    <url>%2F2020%2F03%2F28%2FVlan-tags%2F</url>
    <content type="text"><![CDATA[为什么要为网卡加上 VLAN TAG有时候我们需要将主机或服务器加入同一个VLAN中，在此之前需要配置本地网卡使其发送出去的数据包带有 VLAN 标签，这样才可以被对端的交换机接收。本文会教你如何为 CentOS7 的网卡打上 VLAN，以便与对端交换机的 VLAN 网关通信。 配置步骤开启 CentOS 的 8021q 模块①首先检查本机是否已加载该模块1234[root@localhost ] lsmod | grep 8021q # 查询模块是否正常加载8021q 33208 0 garp 14384 1 8021qmrp 18542 1 8021q ②若该模块未加载，需先加载 8021q模块,再执行步骤 1 检查123456789101112131415[root@localhost ] modprobe 8021q # 加载模块[root@localhost ] modinfo 8021q # 查询模块信息filename: /lib/modules/3.10.0-957.27.2.el7.x86_64/kernel/net/8021q/8021q.ko.xzversion: 1.8license: GPLalias: rtnl-link-vlanretpoline: Yrhelversion: 7.6srcversion: 3D84ADCA65536B17FD7DCECdepends: mrp,garpintree: Yvermagic: 3.10.0-957.27.2.el7.x86_64 SMP mod_unload modversions signer: CentOS Linux kernel signing keysig_key: 52:0A:4E:2D:9D:55:3E:F8:42:01:C1:88:B8:7F:E5:1B:9D:E1:1A:5Esig_hashalgo: sha256 修改原有网卡文件③使用 ip a 命令查看网卡信息，本次添加 tag 标签的网卡为eth012345678910111213[root@localhost ~] ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:0c:29:80:69:1f brd ff:ff:ff:ff:ff:ff inet 192.168.245.129/24 brd 192.168.245.255 scope global dynamic eth0 valid_lft 1738sec preferred_lft 1738sec inet6 fe80::1c28:54a4:1513:c8ee/64 scope link valid_lft forever preferred_lft forever ④修改 ifcfg-eth0 网卡文件，修改 ONBOOT=yes、增加 PROXY_METHOD=none、BROWSER_ONLY=no，如果配置了静态IP需要删除12345678910111213141516171819202122[root@localhost ~] cd /etc/sysconfig/network-scripts/[root@localhost network-scripts] cat ifcfg-eth0TYPE=EthernetBOOTPROTO=none # 不配置IP地址DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth0UUID=0212fe99-0ea0-49bc-a44a-b63275101e6dDEVICE=eth0ONBOOT=yes # 保持网卡开机自启PEERDNS=yesPEERROUTES=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_PRIVACY=noPROXY_METHOD=none # 增加该项BROWSER_ONLY=no # 增加该项 创建带VLAN的网卡设备⑤增加网卡子接口文件 ifcfg-eth0.10 ，此处 “.10” 为命名规范，表示添加的子网VLAN ID 为1012345678[root@localhost network-scripts] vi ifcfg-eth0.10 # 文件内容如下DEVICE=eth0.10BOOTPROTO=noneONBOOT=yesIPADDR=192.168.10.10PREFIX=24NETWORK=192.168.10.0VLAN=yes ⑥创建VLAN网卡1[root@localhost network-scripts] ip link add link eth0 name eth0.10 type vlan id 10 重启网络服务，检验配置是否成功⑦当有多个网卡配置不同的VLAN TAG 时，需要先停止 NetworkManager 服务防止冲突12[root@localhost network-scripts] service NetworkManager stopRedirecting to /bin/systemctl stop NetworkManager.service ⑧重启网络服务12[root@localhost network-scripts] service network restart Restarting network (via systemctl): ⑨验证vlan标签是否创建成功1234567891011[root@localhost ~] cat /proc/net/vlan/eth0.10 eth0.10 VID: 10 REORDER_HDR: 1 dev-&gt;priv_flags: 1 total frames received 0 total bytes received 0 Broadcast/Multicast Rcvd 0 total frames transmitted 11 total bytes transmitted 822Device: eth0INGRESS priority mappings: 0:0 1:0 2:0 3:0 4:0 5:0 6:0 7:0 EGRESS priority mappings: ⑩使用 ip a 命令查看网卡配置,测试对端网关连通性123456789101112131415161718192021222324[root@localhost ~] ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:0c:29:80:69:1f brd ff:ff:ff:ff:ff:ff inet6 fe80::1c28:54a4:1513:c8ee/64 scope link valid_lft forever preferred_lft forever3: eth0.10@eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000 link/ether 00:0c:29:80:69:1f brd ff:ff:ff:ff:ff:ff inet 192.168.10.10/24 brd 192.168.10.255 scope global eth0.10 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe80:691f/64 scope link valid_lft forever preferred_lft forever [root@localhost ~] ping -I 192.168.10.10 192.168.10.1 # 使用-I指定源IPPING 192.168.10.2 (192.168.10.2) from 192.168.10.10 : 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=128 time=0.044 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=128 time=0.121 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=128 time=0.053 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=128 time=0.042 ms 到此就已经成功为 eth0 网卡添加了 VLAN 标签了，可以看到能够与 VLAN 10 的网关192.168.10.1互通]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Vmware中为CentOS添加网卡后丢失配置文件]]></title>
    <url>%2F2020%2F03%2F26%2FAdd-network-device%2F</url>
    <content type="text"><![CDATA[故障描述最近使用 VMware 为已经创建的 CentOS7 添加多张网卡时，发现虽然成功添加了 eth1 网卡并通过 DHCP 获取了IP地址，但是在 /etc/sysconfig/network-scripts/ 目录下却看不到对应的网卡文件 ifcfg-eth1 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[root@localhost network-scripts] ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:80:69:1f brd ff:ff:ff:ff:ff:ff inet 192.168.245.129/24 brd 192.168.245.255 scope global noprefixroute dynamic eth0 valid_lft 1491sec preferred_lft 1491sec inet6 fe80::1c28:54a4:1513:c8ee/64 scope link noprefixroute valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:80:69:29 brd ff:ff:ff:ff:ff:ff inet 192.168.245.131/24 brd 192.168.245.255 scope global noprefixroute eth1 valid_lft forever preferred_lft forever inet6 fe80::cae2:5268:7768:d61e/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@localhost network-scripts] lltotal 261-rw-r--r--. 1 root root 324 Aug 14 2019 ifcfg-eth0 # eth0网卡的配置文件 -rw-r--r--. 1 root root 254 Aug 24 2018 ifcfg-lolrwxrwxrwx. 1 root root 24 Aug 14 2019 ifdown -&gt; ../../../usr/sbin/ifdown-rwxr-xr-x. 1 root root 654 Aug 24 2018 ifdown-bnep-rwxr-xr-x. 1 root root 6532 Aug 24 2018 ifdown-eth-rwxr-xr-x. 1 root root 6190 Oct 31 2018 ifdown-ib-rwxr-xr-x. 1 root root 781 Aug 24 2018 ifdown-ippp-rwxr-xr-x. 1 root root 4540 Aug 24 2018 ifdown-ipv6lrwxrwxrwx. 1 root root 11 Aug 14 2019 ifdown-isdn -&gt; ifdown-ippp-rwxr-xr-x. 1 root root 2130 Aug 24 2018 ifdown-post-rwxr-xr-x. 1 root root 1068 Aug 24 2018 ifdown-ppp-rwxr-xr-x. 1 root root 870 Aug 24 2018 ifdown-routes-rwxr-xr-x. 1 root root 1456 Aug 24 2018 ifdown-sit-rwxr-xr-x. 1 root root 1621 Mar 18 2017 ifdown-Team-rwxr-xr-x. 1 root root 1556 Mar 18 2017 ifdown-TeamPort-rwxr-xr-x. 1 root root 1462 Aug 24 2018 ifdown-tunnellrwxrwxrwx. 1 root root 22 Aug 14 2019 ifup -&gt; ../../../usr/sbin/ifup-rwxr-xr-x. 1 root root 12415 Aug 24 2018 ifup-aliases-rwxr-xr-x. 1 root root 910 Aug 24 2018 ifup-bnep-rwxr-xr-x. 1 root root 13475 Aug 24 2018 ifup-eth-rwxr-xr-x. 1 root root 10114 Oct 31 2018 ifup-ib-rwxr-xr-x. 1 root root 12075 Aug 24 2018 ifup-ippp-rwxr-xr-x. 1 root root 11893 Aug 24 2018 ifup-ipv6lrwxrwxrwx. 1 root root 9 Aug 14 2019 ifup-isdn -&gt; ifup-ippp-rwxr-xr-x. 1 root root 650 Aug 24 2018 ifup-plip-rwxr-xr-x. 1 root root 1064 Aug 24 2018 ifup-plusb-rwxr-xr-x. 1 root root 4997 Aug 24 2018 ifup-post-rwxr-xr-x. 1 root root 4154 Aug 24 2018 ifup-ppp-rwxr-xr-x. 1 root root 2001 Aug 24 2018 ifup-routes-rwxr-xr-x. 1 root root 3303 Aug 24 2018 ifup-sit-rwxr-xr-x. 1 root root 1755 Mar 18 2017 ifup-Team-rwxr-xr-x. 1 root root 1876 Mar 18 2017 ifup-TeamPort-rwxr-xr-x. 1 root root 2711 Aug 24 2018 ifup-tunnel-rwxr-xr-x. 1 root root 1836 Aug 24 2018 ifup-wireless-rwxr-xr-x. 1 root root 5419 Aug 24 2018 init.ipv6-global-rw-r--r--. 1 root root 20671 Aug 24 2018 network-functions-rw-r--r--. 1 root root 31027 Aug 24 2018 network-functions-ipv6 解决方法此时需要自己手动添加网卡配置文件，步骤如下： 使用 nmcli con show 命令查看 eht1 网卡的UUID信息并记录,后续会用到1234[root@localhost network-scripts] nmcli con show NAME UUID TYPE DEVICE eth0 0212fe99-0ea0-49bc-a44a-b63275101e6d ethernet eth0 eth1 7eb403e4-057f-3823-a6c6-6f89c24e6ebf ethernet eth1 # 记下该项 UUID 值 使用 ip addr 命令查看网卡信息，记录 eth1 的MAC地址12345678910111213141516171819[root@localhost network-scripts] ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:80:69:1f brd ff:ff:ff:ff:ff:ff inet 192.168.245.129/24 brd 192.168.245.255 scope global noprefixroute dynamic eth0 valid_lft 1491sec preferred_lft 1491sec inet6 fe80::1c28:54a4:1513:c8ee/64 scope link noprefixroute valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:80:69:29 brd ff:ff:ff:ff:ff:ff # 记下eth1的MAC地址 inet 192.168.245.131/24 brd 192.168.245.255 scope global noprefixroute eth1 valid_lft forever preferred_lft forever inet6 fe80::cae2:5268:7768:d61e/64 scope link noprefixroute valid_lft forever preferred_lft forever 添加新的网卡配置文件，这里复制并修改了 eth0 的网卡文件注：新的网卡配置文件需要使用静态地址，如果使用dhcp可能会出现报错 123456789101112131415161718192021222324[root@localhost network-scripts] cp ifcfg-eth0 ifcfg-eth1[root@localhost network-scripts] vi ifcfg-eth1TYPE=EthernetBOOTPROTO=static # 修改为固定IP地址DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth1 # 修改网卡名称UUID=7eb403e4-057f-3823-a6c6-6f89c24e6ebf # 修改网卡UUID值（唯一标识符）DEVICE=eth1 # 修改系统逻辑设备名ONBOOT=yesPEERDNS=yesPEERROUTES=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_PRIVACY=noIPADDR=192.168.245.131 # 指定IP地址GATEWAY=192.168.245.2 # 指定网关NETMASK=255.255.255.0 # 指定子网掩码HWADDR=00:0c:29:80:69:29 # 增加该行，指定网卡MAC地址 最后重启网网络服务即可。1[root@localhost network-scripts] systemctl restart network]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件下载:wget]]></title>
    <url>%2F2020%2F03%2F04%2Fwget%2F</url>
    <content type="text"><![CDATA[wget命令简述wget是Linux系统中一个从网络下载文件的工具，名称来源于 “World Wide Web” 与 “get” 的结合，意为可以从网上获取文件。支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议下载，并可以使用 HTTP 代理；其便捷之处在于用户退出系统后可以后台继续执行，直到下载任务完成。 wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性。如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 wget常用命令参数基本语法是：wget [参数列表] URL1234567891011-V, --version 显示 Wget 的版本信息并退出-O, --output-document=FILE 将文档写入 FILE。-b, --background 启动后转入后台-i, --input-file=FILE 下载本地或外部文件中的 URLs-c, --continue 继续下载部分下载的文件-S, --server-response 打印服务器响应 --user=USER 将 ftp 和 http 的用户名均设置为 USER --password=PASS 将 ftp 和 http 的密码均设置为 PASS --ask-password 提示输入密码 --proxy-user=USER 使用 USER 作为代理用户名 --proxy-password=PASS 使用 PASS 作为代理密码 wget常用实例重命名下载文件1wget -O newfilename.txt https://www.baidu.com/index.html 后台下载文件1wget -b https://www.baidu.com/index.html 查看下载进度:1tal -f wget-log 终止下载：12ps aux | grep wget //找到 wget 进程号kill -9 进程号 //杀掉下载进程 连续下载多个文件1、创建 download.txt 并将多条下载链接写在文件中1234vi download.txthttp://www.demo.com/001.txthttp://www.demo.com/002.txthttp://www.demo.com/003.txt 2、下载download.txt中的所有文件1wget -i download.txt 从需要账户/密码的网站下载文件12345设置用户名为admin，密码为Admin:wget --http-user=admin --http-password=Admin http://www.demo.com/001.txt当密码中包含特殊字符时（如：* ？# ！ / 等），需要使用 '' 单引号对其进行转义，否则会报错:wget --http-user=admin --http-password=Admin'!'123 http://www.demo.com/001.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器那些事儿—RAID]]></title>
    <url>%2F2019%2F08%2F13%2FRaid%2F</url>
    <content type="text"><![CDATA[关于RAID磁盘阵列（Redundant Arrays of Independent Drives，RAID），可简单理解为 “独立磁盘构成的具有数据备份功能的磁盘阵列”。 通常服务器的存储都是使用多块独立的磁盘组合成一个巨大的硬盘组，利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，这样做的目的是提升性能或数据冗余或是两者同时提升。 RAID将多个硬盘组合为一个成为一个逻辑磁盘，因此操作系统会把这个逻辑磁盘当作一个硬盘对待。这里需要注意的是，一般RAID使用完全相同的磁盘作为组合。 RAID的实现磁盘阵列其样式有三种，一是外接式磁盘阵列柜、二是内接式磁盘阵列卡，三是利用软件来仿真。 ①外接式磁盘阵列柜：最常被使用大型服务器上，具可热交换（Hot Swap）的特性，不过这类产品的价格都很贵。 ②内接式磁盘阵列卡：价格便宜，但需要较高的安装技术，适合技术人员使用操作。硬件阵列能够提供在线扩容、动态修改阵列级别、自动数据恢复、驱动器漫游、超高速缓冲等功能。它能提供性能、数据保护、可靠性、可用性和可管理性的解决方案。通过阵列卡专用的处理单元来进行操作，是目前最常用的一种方式，多集成在服务器中。 ③利用软件仿真的方式，是指通过网络操作系统自身提供的磁盘管理功能将连接的普通SCSI卡上的多块硬盘配置成逻辑盘，组成阵列。软件阵列可以提供数据冗余功能，但是磁盘子系统的性能会有所降低，有的降低幅度还比较大，达30%左右。因此会拖累机器的速度，不适合大数据流量的服务器。 RAID的层级在磁盘运行过程中，取决于 RAID 层级不同，数据会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字；比较常用的有：.RAID 0，RAID 1，RAID 5，RAID 10等，这些只是标准RAID划分，还有比较负责的混合RAID这里就不一一介绍了。 RAID 0 —— 性能RAID 0亦称为带区集。它将两个以上的磁盘并联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，RAID 0的速度是最快的。但是RAID 0既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失。 RAID 1 —— 数据保护两组以上的N个磁盘相互作镜像（也称为镜像模式或RAID 1），只要一个磁盘正常即可维持运作，可靠性最高。其原理为将所有磁盘容量分成两半，在主硬盘上存放数据的同时也在镜像硬盘上复制备份数据，当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。 注：如果用两个不同大小的磁盘建RAID 1，可用空间以较小的磁盘为标准。 RAID 5 —— 数据保护和速度至少需要三个硬盘，使用了Disk Striping（硬盘分割）技术。RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。 同时RAID 5可以为系统提供数据安全保障，但保障程度要比RAID 1低而磁盘空间利用率要比RAID 1高，可以节约存储成本；是一个介于RAID 0 和RAID 1 之间的折中方案。 RAID 10/01 —— 高可靠性和高性能RAID 10是先分割数据再镜像，再将所有硬盘分为两组，视为以RAID 1作为最低组合，然后将每组RAID 1视为一个“硬盘”组合为RAID 0运作。 RAID 01则是跟RAID 10的程序相反，是先镜像再将数据到分割两组硬盘。它将所有的硬盘分为两组，每组各自构成为RAID 0作为最低组合，而将两组硬盘组合为RAID 1运作。 当RAID 10有一个硬盘受损，其余硬盘会继续运作。 RAID 01只要有一个硬盘受损，同组RAID 0的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。 如果以六个硬盘建RAID 01，镜像再用三个建RAID 0，那么坏一个硬盘会导致作RAID 0 的硬盘组不可用，进而导致三个硬盘离线。因此，RAID 10远较RAID 01常用，零售主板绝大部分支持RAID 0、1、5、10，但不支持RAID 01。]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
        <tag>raid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel中的“提示框”]]></title>
    <url>%2F2019%2F08%2F03%2FExcel-verification%2F</url>
    <content type="text"><![CDATA[什么是提示框？提示框其实是Excel中的数据验证提示信息，一般是为了避免输入的信息不符合规范特意在输入的单元格旁边设置一个提示信息。 如何添加？：1、设置数据有效性选中需要添加提示信息的单元格，点击数据—数据验证—数据验证 2、输入提示信息点击数据验证—输入信息，在输入信息中填写想要弹出的提示信息，确认后点击该单元格就可以看到提示信息。 怎样清除？1、清除单个提示信息点击数据—数据验证进入数据验证的设置窗口，点击左下角的全部清除按钮即可。（下图箭头处） 2、批量定位添加了数据验证的单元格①Ctrl + A全选单元格（或点击表格最上家交汇处三角）②接着按键盘上的F5键。填出定位窗口，单击下图的定位条件。③在新弹窗口中选中数据验证。然后点击确定。④系统会自动选中设置过数据验证的单元格。从而批量清除单元格的数据验证提示信息。]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Office</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些关于电脑的故事]]></title>
    <url>%2F2019%2F07%2F26%2FComputer-repair%2F</url>
    <content type="text"><![CDATA[每个会修电脑的BOY都有故事1.能力越大，责任也就越大作为一个懂电脑的BOY，平常被姑娘问的最多一句话就是： “我电脑出问题了，快帮我看一看。” 而作为标准回答，往往也只有一句： 你重启一下试试。 后来的事实证明这样做其实不好。 因为这句话效率过高。 导致姑娘们再没有什么事会联系你。 怎么办，难道只能选择原谅重启键？ 于是当第一次有个姑娘告诉你： “我试过了，重启键没用”的时候。 你才终于体会到，什么叫做能力越大，责任也就越大。 2.没有什么是重启不能解决的，如果有，那就重装系统你知道，如果重启都不能解决问题的话。 那么这件事情的严重性已经到达了常人无法解决的高度。普通人之所以成为普通人。 不是因为他们笨。 而是因为懒。 不是因为懒得去学。 而是因为懒得听你讲。 成熟的你开始懂得原谅。 懂得并不是只有青青原上草才会一岁一枯荣。 每年都应该做的事情之一，还有重装系统。 于是你本着慈悲心肠，从箱底拿出了一个U盘。 你又想了想，说不定姑娘那边也没有可以备份数据的设备。 你嘴角上扬，这点难度对于你来说只是Easy等级。 半小时后，你带着装好刻录好PE的U盘和移动硬盘出了门。 3.修电脑行规第二条：找你修电脑的人从没做错过什么一路上时间过得很快。 因为在你的脑海里面已经想过了所有可能出现的故障原因。 你来到了姑娘住的地方。 她很开心，你一进屋就给你泡了一杯茶。 你坐下，开始与她交谈。 在你反复询问之后，姑娘只了给你两个回答： 我并没有乱点什么。 以及，它突然就这样了。 你很欣慰。 因为姑娘没有粗暴地告诉你： “你不是什么都会吗，怎么连这个都不知道”。 那一刻，你连你们的孩子应该在哪里上小学都想好了。 4.存在即合理。–黑格尔你效率很高，打开了电脑。 然后发现自己还是太年轻。 因为屏幕右下角赫然显示着一行大字： 您的开机时间4分59秒，已击败1%的电脑。 在你看来。 几乎是这样的。 现实世界里的5分钟很快。 而虚拟世界很慢。 你觉得这是龟速，而姑娘则毫无反应。 这让你感到绝望，因为这表示你们是两个世界的人。 你抱着试一试的心态。 想看看能不能不用重装系统。 于是看着右下角不停闪动的数十个小图标。 你知道一场大屠杀在所难免。 你问姑娘哪些可以删掉。 姑娘说全部都有用。 你说这样开机会很慢。 姑娘说她用了半年已习惯。 于是这个有耐心的姑娘在你眼中越来越接近贤妻良母的形象。 5.科技是第一生产力你告诉姑娘。 这些软件都免不了被删除的命运。 因为你即将重装系统。 血洗整个C盘。 这时姑娘表现出来一丝怜悯。 难道就只有这一个办法了吗？ 只有这一个办法。 你坚定地说道。 有哪些需要保存的文件赶紧挪到其他盘里。 姑娘听你的话。 打开血槽已经见红的C盘。 与之相对的是空空如也的D盘。 但她什么都没有移动，说道： 我不知道哪些是我需要保存的。 你心中有数，她自然是看不懂那些文件夹的意思。 于是你问： 办公文件还有视频什么的有没有。 姑娘说没有，我的办公文件都存在公司的电脑里，视频都是用恨奇艺，劣酷，腾慢看的，偶尔还去C站看动漫。对了最近有一部电视剧很火你看了吗。 长久以来的自我训练让你有了迅速提取关键词的能力。 上一句话中的有用信息只有两个字：没有。 于是你自动屏蔽了无用信息。 你默念了一遍：没有。 于是姑娘不再说话，让你安心做事。 嗯，科技是第一生产力。 6.天下武功，唯快不破你开始重装系统。 姑娘想要学习你的操作。 你欣然同意。 在以往十余载的人生中。 你已对BIOS设置驾轻就熟。 你炫技式的操作快得让自己颅内高潮。 电光火石之间你已按下F10并敲下了回车键。 系统重启。 姑娘说你太快了想再来一遍。 虽然哪里不对但你依然当做是一种夸奖。 于是你再次演示。 姑娘似懂非懂，不明亦觉厉。 你面如平湖。 且看熟悉的Windows PE缓缓在屏幕上展开。 7.祖师爷都无法搭救姑娘看着Windows PE很开心。 以为你已经装好。 而你却说不是，这才刚刚开始。 接着依然是姑娘看不懂的操作。 几下便开始了装机。 出现这个界面的时候。 你知道稳了。 姑娘说她认识这个，这个是太极。 你说不是，这个是祖师爷。 姑娘以为你信道教。 你却说你是根正苗红的唯物主义者。 你忘了，这个时候的你应该回答你会看手相。 8.You‘re what you experience.十几分钟，系统装载完毕。 一切顺利，进入了新系统。 姑娘说辛苦你了。 你说小事情。 你问还有什么软件要安装。 她说常用的都装上。 你话不多说，几分钟搞定。 当她看到熟悉的软件又回来的时候。 高兴的样子像极了你以后的女朋友。 然而姑娘说：再装一个杀毒软件吧。 马上让你陷入了深深的回忆。 你的脑海里无数个声音在回响： 我电脑越用越慢，你推荐的是什么垃圾杀毒软件。 你的杀毒软件一点用都没有，我电脑还是中毒了。 这个杀毒软件老是把其他软件阻止了，怎么把它卸了。 你根本就不会修电脑！ 。。。。 你回到现实，惊恐地拒绝了姑娘的请求。 姑娘不解。 央求你推荐一个。 你几乎跪下。 表示自己从来不用杀毒软件。 姑娘一脸疑惑。 但不再追问。 你心中默念。 修电脑行规第三条：绝不帮人装任何杀毒软件。 9.西西弗斯的石头关了电脑，你松了一口气。 不过是结束了一次毫无悬念的修理。 姑娘很开心。 说要请你吃饭。 你欣然应允。 姑娘说她男朋友也快回来了。 你们三人可以一起吃。 悲伤来得太快。 你只能消化。 这时一个电话响起。 是另一个姑娘。 我电脑出问题了，快帮我看看。 你沉吟半响。 回答道： 我马上来。 10.修电脑第一条行规临别前你问姑娘。 为什么不让自己的男朋友来修电脑。 她说怕耽误他和朋友打球。 那时你感受到自己心里某一块，又坚硬了一点。 路上，你给刚才打电话来的那个姑娘回了过去。 ”你男朋友在不在身边“。 “他在，可是他不会啊”。 ”那你重启一下试试“。 这时候你终于回想起。 修电脑是有第一条行规的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为GitHub Pages添加域名解析]]></title>
    <url>%2F2019%2F04%2F27%2Fcname-for-GitHubPages%2F</url>
    <content type="text"><![CDATA[关于域名经过我自己的捣鼓，发现网站是可以访问了，但是地址有点太长，就想着换上自己的简短域名方便大家记忆。So，就有了这篇博客… What？什么是域名网域名称简称域名、网域 (Domain Name)，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。可以理解为域名是为了方便记忆以取代IP地址的一个代称，一个域名对应一个IP地址（理论上是可以是多对多关系），但是通常情况下 一个域名同一时刻只能对应一个公网IP地址 。比如我的网站原来的网址是 poison77.giuhub.io 使用了域名解析后访问 poison77.com 即可跳转到我的博客地址，这是通过 域名系统(DNS)解析实现的，当然你们要做的就只有记住 poison77.com 然后将它输入到你们浏览器的地址栏回车就好了😏 Where?在那里注册域名如果你想要注册一个域名，就需要找到一个域名注册商，帮你向CANN申报。如今国内比较有名的有阿里云、腾讯云等等；国外的著名域名注册商有Godaddy、name、enom、domainsite…. 一般推荐大家使用国内的解析，因为速度较快，但是国外的域名网站可能会比较便宜，emmmmm，毕竟鱼和熊掌不可得兼。😡 注册过程也很简单，但是这里提醒大家一个域名将会代表你的信息或者喜好很长一段时间，所以要注意它读起来有没有什么特别的含义，不要太关心它的商业价值。选中你喜欢的下单即可，然后可以在自己的注册域名所在网站的账户中看到购买的域名，如果是在国内注册的，不要忘了实名认证，不然的话解析是不可用的，具体过程参考各自网站的实名认证规则。 How？如何使用购买的域名如果你购买了自己的域名，在解析域名之前首先要知道自己要解析的网络地址，就是你的VPS的IP地址或者你网站以前的地址，这里我以腾讯云为例： 首先，对我购买的域名进行解析操作： 打开每个选项都有详细的说明，这里我们选择主机记录、记录类型、线路类型、记录值TTL保存即可，这里如果要为GitHub Pages的静态网站解析域名，只需要添加一条 @ 和 www 的CNAME解析即可 接着来到Github页面，打开你托管网站的仓库，进入找到Settings，在此项中下拉找到GitHub Pages,将你的域名填入Custom Domain选项中Save即可,可以看到上面的提示变成了 Your site is published at https://domainname.com/,表示成功。记录添加完成后一般要等待2-10分钟就可以使用你自己的域名访问网站啦！ 这个强制使用HTTPS访问在第一次添加域名的时候是不可勾选的，需要等第一次解析成功十几分钟后即可勾选，选上之后就可以使用更安全的https连接到你的网站了。 本教程就到此结束，如果实践的小伙伴遇到了什么问题可以评论里留言啊，不要忘记填写邮箱方便我回复你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows激活]]></title>
    <url>%2F2019%2F04%2F24%2FActivation-kit%2F</url>
    <content type="text"><![CDATA[关于Windows激活方式可能有很多人新装了WinServer 2008、或重装了Win10系统后要进行系统激活，不然的话系统右下角会出现几行数字水印，非常的烦人，今天就给大家介绍几种常见的激活方法。 查看自己系统是否永久激活：打开CMD，输入slmgr.vbs -xprslmgr.vbs -dlv ：显示最为详尽的激活信息，包括：激活ID、安装ID、激活截止日期 KMS激活最常用的KMS激活方式，全称Key Management Service。它其实是微软官方认可的一种系统激活方式。这个激活方式主要用于企业计算机的批量激活。这种激活方式依托于一个激活服务器（Activation），通过在你自己的电脑安装KMS客户端与远程服务器通信获取密钥信息即可激活成功，比较常见的KMS工具有KMS Pico、HEU KMS Activator、小马激活工具…其原理一般都是在本地计算机中建立一个虚拟激活服务器（服务），并发送已激活的模拟信号。但是这种激活方式微软已经采取了措施，不仅让Windows Defender报毒，还在系统更新时直接删除该任务。所以大家在激活时记得记得记得（重要的事情说三遍）关闭杀毒软件 但是如果使用联网远程服务器激活，远程服务器的管理员不光可以远程激活你的电脑，还能够远程取消激活乃至控制你的电脑，所以大家激活需谨慎，在经济允许的情况下支持正版。 想深入了解可以跳转：微软官方关于使用密钥管理服务激活的说明 使用密钥激活这个是最为安全和简便的方式，而且一旦激活成功就是永久的，但是Win10的密钥特别难找，往往搜了一大堆也没有几个可以用的，这里我建议支持正版的用户可以去某宝购买。 这里我分享几个Windows Server的激活码给大家，使用方法是使用管理员权限打开CMD，依次执行下面的命令，KMS激活一般180天，到期后再次激活。 1234slmgr /ipk WMDGN-G9PQG-XVVXX-R3X43-63DFG //安装 windows 密钥slmgr /skms zh.us.to //设置kms服务器slmgr /ato //激活 windows 系统slmgr /xpr //查询激活状态 windows server 2019零售版永久激活码： Windows Server 2019 Datacenter Retail：[Key]：C4VN-4GQBW-WYPTV-3BD66-FVXR6 Windows Server 2019 Standard Retail：[Key]：N3P28-TW9C9-69PWP-YQVC3-YBKR4 Windows Server 2019 Essential Retail：[Key]：NMB98-MKJBC-FTVQ9-J3XK6-QYKTQ Windows Server 通用密码1TJMM6-8MPRG-3JVTK-Q8TM4-73TYX Windows Server 2008 Enterprise 企业版万能密码1234P36VD-22V68-JVM2W-DBC77-MK98WFJCXR-2D9YR-YD2DR-92DMX-HJF9DH77K6-V9P48-H4BJ7-KR9WR-D8YR8YTKP9-MWBPB-RJ6MY-CXTDG-FKTYH Windows Server 2008 Standard 简体中文正式零售标准版12348YTF9-YGWD8-B87YF-46DMM-3Q6674H8B2-HMF2F-73R7D-BWHC3-C8CQ9VWRJT-DJJYR-QG7YD-Q7X73-TQCHT87PC6-CTW7M-C3DVH-TYGGR-BRJPM windows server 2008 Enterprise 简体中文正式企业版1234YV6BQ-YR3DC-7JM83-R44J8-V7XVM2PCB6-H32MQ-DQFD4-JR63C-CB962FBT94-726VQ-GBK3Q-7HCKX-488YJTBT4R-72VTH-VG89P-KXGFC-CHFR4 Windows Web Server 2008 简体中文正式网站服务器版1234CXGWX-RXCVX-CM4TH-9PM2X-FQ6BX39KGK-BRYMK-DDXMX-77XC7-VM9Q9PMPR7-4D4TX-K8GKM-B43JV-WH2XVMFTPC-GGRR4-RYYXP-BPXJD-FKMGF 激活工具激活这里放几个链接吧，供大家下载使用：Win10数字权利激活 → 提取码:9hjrWin7及以下版本激活 → 提取码:4011Office激活（支持2019） → 提取码:mvbl]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[用了一周时间终于把网站搭好了，本站基于GitHub Pages托管，使用hexo环境搭建，使用了NEXT主题，目前刚刚起步，都还在完善中，欢迎各位大佬莅临小站。 写在前面的话Hello，我是Poison，好多人都问我为什么用毒药这么奇怪的一个英文名字，可能是因为一开始游戏早期ID是它，后来懒得改了，所有的账户名字也都是这个了，还有一个好处就是从来不会被占用哈哈。本人热爱技术，算是半个程序猿，喜欢捣鼓电脑，同时热爱运行，乒乓球、羽毛球信手拈来（吹一波），希望大家有空可以为我的GitHub积攒点流量，网址：Poison77 Thanks1$ echo "Thanks for the support of my friends."]]></content>
  </entry>
</search>
